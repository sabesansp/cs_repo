(1) How does "printf" statement in C output the characters to the console ?
  -> link {vprintf} => printf(calls the vprintf function with stdout) 
     http://sourceware.org/git/?p=glibc.git;a=blob;f=stdio-common/vfprintf.c;h=fc370e8cbc4e9652a2ed377b1c6f2324f15b1bf9;hb=3321010338384ecdc6633a8b032bb0ed6aa9b19a
  -> 

(2) Implement a 3-way merge on three sorted lists ?

  -> Example : a(4){i} = [3,7,9,10], b(3){j} = [45,78,98], c(4){k} = [87,567,1000,3456] 
  -> output list m{o} = [ ] 3<45<87 => 3 || m=[3] || o=1,i=1,j=0,k=0
  -> 7<45<87 => m=[3,7] || o=2,i=2,j=0,k=0
  -> 9<45<87 => m=[3,7,9] || o=3,i=3,j=0,k=0
  -> 10<45<80 => m=[3,7,9,10] || o=4,i=4(>len(a)-1),j=0,k=0
  -> discard(a) because i = len(a)
  -> 45<87 => m=[3,7,9,10,45] || o=5, j=1, k=0
  -> 78<87 => m=[3,7,9,10,45,78] || o=6, j=2, k=0
  -> 98>87 => m=[3,7,9,10,45,78,87] || o=7, j=2, k=1
  -> 98<567 => m=[3,7,9,10,45,78,87,98] || o=8,j=3,k=1
  -> discard(b) because j = len(b) 
  -> copy rest of the elements from c, k=2..3

(3) Suppose S and T are two ordered dictionaries each containing n items. Both are implemented via 
sorted arrays and do not have any keys in common. Describe an O(log n) time algorithm that outputs the 
item whose key is the lower median in the union of S and T. For example, when the keys stored in S and
T are S = [3,6,7,9] and T = [-1,1,2,8], the lower median key is 3

  -> ex : S = [3,6,7,9] ; T = [-1,1,2,8] n = 4
  -> S U T = [3,6,7,9,-1,1,2,8]
  -> What is a median key ? (q)
  -> median is the mid-value of a set of observations
  -> n is odd (3) => median value would be A(n/2) (zero-indexed) {3/2 = 1}
  -> n is even (4) => median value would be [A(n/2-1) + A[n/2])/2
  -> In S, median value = (6+7)/2 = 6.5 (floating-point) technically
  -> In T, median value = (1+2)/2 = 1.5 (floating-point) technically
  -> U = merge(S,T) = [-1,1,2,3,6,7,8,9] 
  -> median(U) = U(n/2-1) if n is even
  ->           = U(n/2) if n is odd
  -> merge the sorted arrays (preserving the sorted order and apply the formula to get the result) 
  -> this approach produces a O(n) algorithm
  -> but I am solving this problem for a O(log n) algorithm
  -> the expensive operation here was the merge step
  -> I could actually accomplish this without the merge step
  -> pick first element of S => 3
  -> compare with T(n/2) 3>2 => search in the right half T(n/2+1) .. T(n-1)
  -> take the median value of S and T {S(n/2-1), T(n/2-1)} 
  -> m(S) = 6, m(T) = 1
  -> first value between 1 and 6 is the median of the union of the list
  -> search in left half of S (1..n/2-2) and search in right half of T(n/2...n-1)

(4) Google interviewing process :

  -> (1-2) phone interviews
  -> upto 5 on-site interviews
  -> Local hiring committee(HC) review
  -> Regional & company HC review
  -> Offer
  -> link = https://www.youtube.com/watch?v=oWbUtlUhwa8
  -> What to expect => {Short Introduction/"The Meat" or a technical assessment/Close with your questions}
  -> Engineering skills assessment  => {write good code/algorithms & data_structures/analytical_skills/sound_design}
  -> review algorithms & data structures
  -> practice in a language you are familiar with, like java {most of the time, I have used Java}
  -> no pseudo-code
  -> "Think out loud => ask_questions()"
  -> in-depth => how do we think about complicated problems
  -> right answer would be nice but it is not necessary => your thought process is more important
  -> sample_interview_question : Write a program that breaks up a string of words with no spaces into a string with the appropriate spaces
     # example : fastman => fast man
     # disambiguate expected result => More than 2 words ? empty string ?
     # State and clarify key assumptions : expected result, any memory or performance reqts etc
     # where do the words come from ? use a dictionary
     # clarify the function signature
     # going to the whiteboard and solving problems directly is a bad thing
     # look for edge cases
     # refine solution {clarify_assumptions(), rinse_repeat(), compare_solutions()} 
     # I do not need to remember apis

(5) Implement a function to find the first character in a string which only appears once

  -> Example => abcdeeffghh {answer => a}
  -> questions => String = null, repeat characters {1111111}, unique character at the end of a string, 1-character string 'a'
  -> Programming Language => Java
  -> findFirst(String str) {java} 
  -> a => 1 {index} = 0
  -> b => 1
  -> c => 1
  -> d => 1
  -> e => 2
  -> f => 2
  -> g => 1
  -> h => 2  

