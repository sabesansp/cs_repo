P : Go through the python apis written by Shashank and replace the staf calls inside vdnet with these apis

[2766 mins]


# S1: Download the api mac timer to record the time taken to complete this activity
                 
                 
# S2: Write down a preliminary plan for completing this activity

 # Pick one api like "powerOff" 
 # Follow the same process as "powerOn" implemented by Prabuddh
 # Initial definition of process : code -> test -> review -> rework * {goes back to code}
                                   ------------------------> check-in 
 # api_1 -> code -> test -> review -> rework
         -> code -> test -> review -> rework
         -> code -> test -> review -> check-in
   [ a sample cycle which has two rework units based on comments ]
                 
                 

# S3 :  To be able to implement the plan what would be required ? {"pre-req"}


 # File a bug for completing the task
  # bug_number = [#1374435]
  # link_bookmark() // bookmarks the link for the bug

 # Set up the vdnet code base on dbc
  # command  = "ssh ssaidapetpach@pa-dbc1109.eng.vmware.com" | password = "*"
  # n[files_modified] = 2


  # "SP" : Issue a command like "dbc-connect" from command line and connect to the place where repo is checked out
   # use alias called "dbc-connect" and place $command as the value in bash_profile

   # "SP" : makeLoginPasswordless()
    # from host, generate key "ssh-keygen -t rsa"
    # public key stored in "/Users/ssaidapetpach/.ssh/id_rsa"
    # copy the key and move it to the target host using a command like
      --- cat ~/.ssh/id_rsa.pub | ssh b@B 'cat >> ~/.ssh/authorized_keys'---
  
  # "SP" : setup the vdnet master controller to be able to execute the code
   # login into the esx host and check the ip of the master controller 
   # forgot the ip of the esxi host and unable to login
   # use the kvm switch to check the console
   # kvm switch not operational
   # File a "HelpNow" ticket for this issue {INC0087727} 	  
    # This is up for review tomorrow morning (12/17/2014}
    # ---problem solved here---  
   # esx_host_ip = 10.33.75.228

 # Go through the link Prabuddh sent :
  # link l = [https://gitreview.eng.vmware.com:8443/#/c/10978/,
              https://reviewboard.eng.vmware.com/r/656157/] 
  # files
    - TDS/EsxServer/Stability/RPMTTds.pm
    - VDNetLib/VM/ESXSTAFVMOperations.pm
    - pylib/vmware/vsphere/vm/api/vm10_power_impl.py
    - pylib/vmware/vsphere/vm/api/vm_api_client.py
  # Shashank's code link l1 = [nsx-qe/vdnet/automation/pylib/vmware/vsphere/] 
  # Sent comments on the review on gitreview


# S4 : Implement the vmops power off function first
 
 # file = "VDNetLib/VM/ESXSTAFVMOperations.pm"
 # precondition =  "Prabuddh checking in the file"
 # plan what sort of implementation will go into the file
 # comment in the bug about the precondition
 # waitForCheckin()

# S5 : Access the vdnet master controller [sub-problem from S3]

 # Deploy a windows 7 enterprise edition vm in fusion
  # Where can I find a windows 7 vm ? 
  # search("source.vmware.com")
  # link = "https://kb.eng.vmware.com/node/1813"
  # follow the steps in the "link" above  
 # Install vsphere client in the vm to access esx box (10.33.75.228)
  # where can I get vsphere client ESXi 5.0.0 ?
  # search("source.vmware.com",
           "vsphere client for ESXi 5.0.0"))
  # link = "vilib.eng.vmware.com/Binaries"
  # bring_in("latest_vsphere_client_build")
 # vdnet_mc_ip = 10.33.74.138
 # find("vdnet_site_page)
  # link = "https://sites.google.com/a/vmware.com/vdnet/" {bookmarked}

# S6 : Evaluate if a new vdnet master controller can be deployed in wdc
 
 # search("vdnet_site")
 # mc_deployment_pod = ~netfvt/wdc-mc
 # ucs_private_cloud = vc_ip = 10.144.136.10 {login (user:root/pwd:ca$...)}
 # NIMBUS_ovf_deploy_command here:
  # NIMBUS_CONFIG_FILE=~netfvt/master-config.json NIMBUS=wdc-mc /mts/git/bin/nimbus-ovfdeploy -d ssaidapetpach-mc-x86-1 <link_to_ovf>
 # Do not use the nimbus-ovf-deploy command, instead deploy ovf in MC-depository directly
  # vmware_client_integration plug-in needs to be installed first on the vsphere web client
  # install("vmware_client_integration_plugin")
  # manual deploy of ovf in "MC-depository" resource pool 
  # wait("until_deployment_completes")

# S7 : On the new vdnet master controller, test deployment of a sample vm with guest os

 # search(src="vdnet_site",
          keyword="vm_deployment")
 # ip_recv = 172.* on vlan 27
 # change vlan to fabric A 1360  and restart the vm
 # vdnet_mc_ip {wdc-lab} = 10.144.137.217
 # program_passwordless_login(vdnet_mc_ip)
 # use("~/yaml/sample.yaml") on dbc
 # NOTE : 29 mins down, yet to find the "context"
 # "SP": deploy vc, esxi, a vm with gos on esxi
  # rpmt yaml => copied over to "~/yaml/rpmt.yaml"
  # add "ssaidapetpach" to sudoers file => 
    "sudo adduser ssaidapetpach sudo"
  # "SP": No deploy_testbed.log gets created
   # String = "Checking or deploying testbed, please wait.. watch deployment logs at 
               /tmp/vdnet/20141222-172625/deploy_testbed.log"
   # There is no file ("deploy_testbed.log") created in the specified folder
   # Where is this log statement printed in code ?
   # VDNetLib::Session::Session:2726
   # "SP" : At what point in the code is "deploy_testbed.log" created ?
    # search("deploy_testbed.log") : 
      grep -i -r -v "deploy_testbed" <path_to_folder>
    # The search results were not useful
    # Start from the entry point "E" : vdnet/automation/main/vdnet
    # calls "e1" : vdnet/automation/main/vdNet.pl
    # calls "e2" : new() {vdnet/automation/VDNetLib/Session/Session.pm}
    # calls "e3" : ConfigureLogging() {vdnet/automation/VDNetLib/Session/Session.pm}
    # ...calls "e4" : setup_logging() {vdnet/automation/scripts/deployTestbed.py}
     # does not create the file "deploy_testbed.log" even though it is defined as a file handler for logging
     # a separate prototype for this works to create the file in the same directory as the code tries to do
   # re-run the test case with a higher log level
   # set up a dbc account in wdc
   # 22 mins for the next line to be printed after "deploy_testbed.log"
  # "SP": VM deployment fails
   # vc.1 ip address: 10.144.137.107,
     esx.1 ip address: 10.144.138.186, 
     esx.2 ip address: 10.144.138.136
     vm.1 => powered on || 
     name => 1-RHEL63_srv_64-local-1056-582dae85-67af-48d1-9d18-0f1e8792cbe0 || 
     path => /vmfs/volumes/datastore1/vdtest-12300/VM-1/RHEL63_srv_64.vmx
     
   # 322 secs [FAIL]
   # useful links
     Session log file: /tmp/vdnet/20141223-184933/vdnet.log
     Racetrack link: http://racetrack.eng.vmware.com/result.php?id=1996575
     Base log dir for this session: /tmp/vdnet/20141223-184933
     Debugging tips	: http://goo.gl/Gllc1k
     Perl exited with active threads:
	1 running and unjoined
	1 finished and unjoined
	0 running and detached    


# S8 : Complete "reboot()" method first in HostOperations.pm since it is taking time to check in

 # update_bug(msg) : bug_1374435
 # infrastructure : 1 esxi host
 # reboot.yaml : one_esxi_host
 
 # SP => Cannot login into mc {10.144.137.217} 
  
  # mc was powered down
  # power up the mc
  # ping the old ip => pingable
  # vdnet_mc_ip changed
  # vdnet_mc_ip = "10.144.138.31"
  # login_problem_solved

 # SP => mount point for w2-dbc201 was not present in mc 

  # root_cause = "ip_changed" => "mount_points_lost"
  # cmd  = "sudo mount w2-dbc201.eng.vmware.com:/dbc/w2-dbc201/ssaidapetpach /dbc/w2-dbc201/ssaidapetpach"
  # logout and test_login()
  # prompt = $vdnet_src_dir

 # SP => Figure out a specific test case for reboot 

 # SP => Code up the condition and understand the flow of the code 

  # File = VDNetLib/Host/HostOperations.pm
  # Set_of_Transformations 'T' = {
   # Add "VDNetLib::InlinePython::VDNetInterface qw(CreateInlinePythonObject
                                                    ConfigureLogger 
                                                    CallMethodWithKWArgs);"
     in the beginning
    # qw => inserts quotes around the words and passes it to use function
      which will use the functions from VDNetInterface
   # In reboot() => add this line $pyObj = $self->GetInlinePyObject()
   # $result = CallMethodWithKWArgs($pyObj, 'reboot', {});
     {this method defined in pylib/vmware/vsphere/esx/api/esx55_power_impl.py}
   # comment the old code and put in the new code
   
  # Test_Case : EsxServer.VMKTCPIP.VMKTCPIP.EEsxReboot
   # comment out rest of the parts
   # problem while executing the testcase 
   # needs to be dealt with, as a separate sub-problem 



# S9 : Come up with a strategy to comment lines 40-93

 # comment : apply('#')
 # try command = ":40,93s/^/#"
 # this command works
 # for uncommenting command = ":40,93s/^#/"
 

# S10 : Solve sub-problem {node /testbed/host/1 obj does not exist}

 # base log dir : /tmp/vdnet/20150106-200432
 # Use this as the basis for solving this problem 
 # changeDir(1_TDS...)
 # error_msg_1 = "Node /testbed/host/1 does not exist"
 # code_unit = "VDNetLib::Common:Zookeeper:412"  
 # esx.1.ip address = 10.144.139.87 {extend_lease() as appropriate}
 # try to save the testbed first 
 # base log dir = /tmp/vdnet/20150107-154100
 
 # search(zookeeper_base_log_dir)
  # zookeeper_base_log_dir = "/tmp/vdnetsnap/rpmt/zookeeper-19816"
  # changeDir(zookeeper_base_log_dir)
  # found(bunch_of_scripts)


 # reboot the mc and retry()
 # saw the same error
 # Reason : The testbedspec in the tds was empty and nothing got written to zookeeper node
 # populated the testbedspec in tds and the error was gone


# S11 : Received an exception "InvalidState" while executing the reboot api

 # msg = "The operation is not allowed in the current state"
 # The "Force" parameter needs to be set to true
 # Pass this parameter in the KW arguments list 
 # When 'True' is passed, there is a runtime error
 # passHash('force' => 'True') : {ERROR} => expecting bool but got a str
 # passHash('force' => True) : {SYNTAX_ERROR}
 # passhash('force' => 1) : {NO_ERROR}


# S12 : Implement the check-in 

 # deploy 2 esxi => 10.144.139.91, 10.144.138.132
 # test passes :  http://racetrack.eng.vmware.com/result.php?id=2023036
 # prepare(code_checkin)
  # post review => https://sites.google.com/a/vmware.com/vdnet/Miscellaneous/10-0-git-vs-perforce/use-case-1
  # delete whitespaces at end of line & remove tabs => ":%s/\s\+$//"
  # post-review <commit-id>
  # git commit --amend <file>
  # post-review <commit-id> -r <review_num> {re-post into the same review_num}
  # git push review HEAD:refs/for/master {push to gerritt -> submit} 


# S13 : Pick second api to be completed

 # LISTVSWITCH could be a candidate
 # source_file = "...Switch/VSSwitch/VSSwitch.pm"
 # line_number = 126 {first_usage_of_LISTVSWITCH}
 # pylib_file = "pylib/vmware/vsphere/esx/vsswitch/api/esx55_crud_impl.py"
 # usedPorts in tuple at source_file does not correspond to numPortsAvailablein SwitchSchema
 # !correspondence(usedPorts{source_file},
                   numPortsAvailable{pylib_file}) // code to convert the previous line
  # N{tests(GetvSwitchProp)} => 0   
 # -diversion-coursera      
 # -diversion-gambit-scheme


# S14 : Unit test review { https://reviewboard.eng.vmware.com/r/731281/ }

 # author : prabuddh
 # review published : {optimization, blank_spaces}

# S15 : shortlist a set of apis to be transformed into the pylib equivalent

 # -diversion-send-solution-on-pyvim-sslthumbprintdata-add-host-to-cluster
 # api_list_1 = [LISTVMKNIC, UPDATEPCIPASSTHRUCONFIG, LISTNICS, LISTDVPG, DISCONNECT]


# S16 : Work on "api_list_1"

 # api_list_1[0] = LISTVMKNIC
  # api.location = Host/HostOperations.pm : 4724
  # api.name = "ListVmknics"
  # api.callers = ["/Workloads/HostWorkload.pm",
                   "/Workloads/AbstractSwitchWorkload.pm"]
  # function : transform()
  # transform() { copy_transform(reboot);}
  # lines = { my $pyObj = $self -> GetInlinePyObject(); ||
              my $result = CallMethodWithKWArgs($pyObj,'listvmknics');
  # pylib_api_location = "...pylib/vmware/vsphere/esx/api/esx55_adapter_impl.py"
  # pylib_api_return = list_vnic() // returns nics to the caller 
  # If there are no vmknics, "nics" datastructure would be empty from pylib
  # There will be no case where this will return null
  # Checks in the caller have to be modified accordingly
  # "list_vnic" method returns the list of virtual nics {python list}
  # "ListVmknics" routine in HostOperations.pm expects a hash stored in $result -> {result} 
  # what does $result -> {result} contain ?
   # examine api.callers
   # context(usage) :
    # my $result = $hostObj -> ListVmknics()
    # check() : ref($result) eq "ARRAY"
    # foreach item : @$result
    # if($item -> {'Interface'}  =~ m/$interface/i) {vssPortgroup = $item -> {'PortGroup'} [AbstractSwitchWorkload.pm]
    # if($item -> {'PortGroup'} eq $hostOpsHash -> {testpg}) { $device = $item -> {'Interface'}; [HostWorkload.pm] 
  # find one test that uses ListVmknics
   # test_case : "EsxServer.VMKTCPIP.VMKTCPIP.RFRoute" deletes vmknics in its workflow sequence
   # needs only one esxi host {which is a good candidate for testing}
   # reuse reboot.yaml for testing purposes
   # spawn the testbed :  ./vdnet/automation/main/vdnet -c ~/yaml/reboot.yaml -t EsxServer.VMKTCPIP.VMKTCPIP.RFRoute --testbed save
  # deployed_esx_ip : 10.144.138.63
  # flip number of iterations to 1 instead of 20 in the TDS
  # passed_log : http://racetrack.eng.vmware.com/result.php?id=2056531

  # p1 : Unable to get a print statement to the log from ListVmknics (Is this method even being called ? )
   # Need to start from this section tomorrow (verify the code flow path)

  # p2 : changes had to be discarded because of a problem in git workflow
   # Need to solve this problem of merging code before proceeding to avoid such pitfalls



# S17 : Choose one api to be worked upon and submit it in the git repo {api chosen = LISTNICS}

 # Choose a test that exercises the GetPCIId code path 
 # file that contains the pylib api = ...pylib/vmware/vsphere/esx/api/esx55_adapter_impl.py
 # pylib api = "list_pnics"
 # testcase to be run that involves "EnableFPT"
 # key_handle = "...VDNetLib/Workloads/HostWorkload.pm" : method = "InitializeHostPhysicalComponents"
 # what is the key used to init the vmnics ? => passthrough
 # do not test this now : make changes for each api and make a local commit in a local git branch
 # need to address S16.p2 ASAP with an urgency



# S16.p2 : Resolve the git workflow for committing the changes to the pylib apis 

 # Make a change for api_1 {LISTVMKNICS} for example and commit in a local branch
 # Do not worry about testing this method yet 
 # implement the change for LISTVMKNIC using the pylib api
 # commit the change to the api in the local branch
 # "delta-f" is stored in the local repository
 # run a small experiment
  # examine the file HostOperations.pm on master branch and check if the change was available
  # the change is not available as expected which confirms the theory that the pylib-api-calls branch has an updated version of the file
  # changes made to a certain file are only local to a given repo
 # good read : http://www.git-scm.com/book/en/v2/Git-Branching-Basic-Branching-and-Merging
 # chapter 5 of git workflow also might be of importance to the reader


# S18 : Take a count of the apis that have been completed to establish context
 
 # 1 api => LISTVMKNICS 
 # replay the commit on top of the existing commit => rebase to master from pylib-api-calls


# S19 : Implement a commit on the next set of apis [ UPDATEPCIPASSTHRUCONFIG, LISTNICS, LISTDVPG, DISCONNECT ] 

 # Make notes on why I am not taking up these apis now {on the google_docs}


# S20 : Next api to be implemented => selectvnic()/deselectvnic() | pylib_api = "enable_vmotion"

 # file_to_be_changed {fn} = "VDNetLib/NetAdapter/Vmknic/Vmknic.pm" {fn} 
 # method_to_be_changed {mn} = "SetVMotion"
 # lookup(fn) && change(mn) 
 # Q1 => what object needs to be passed as "client_object" into the enable_vmotion api ? 
 # Q1 needs to be answered first thing in the morning tomorrow
 # postpone(Q1)
 # why is the portgroup name passed as a parameter to "mn" ?
  # Enable/disable the vmknic connected to the portgroup that has the portgroup name
  # enable_vmotion(vmknic | connected(vmknic, pgname))
 # Design_question : Why is the portgroup name passed as a parameter to enable/disable vmknic ?
  # probably due to the constraint imposed by the staf sdk call
  # constraint{staf_sdk_call} - Probability
 # What are the steps to be taken in order to transform this into a pyvim api call ?
  # p1 : Get the vmknic object and call enable_vmotion on that object
  # api : enable_vmotion(cls, client_object, enable=None)
  # cls -> class, client_object -> object to be invoked, enable -> parameter
  # steps for accomplishing p1 is not clear yet
 # How can p1 be solved ?
  # client_object -> instance_of(vmknicAPIClient)
  # How can I create vmknicAPIClient instance ?
   # Before solving this, how did the reboot api work ? {workflow}
    # my $pyObj = $self->GetInlinePyObject();
    # what does $self contain ?
    # search for callers of reboot() api 
    # caller = api : "RebootHostsInClusterSequentially()": 
               file :  [..VDNetLib/VC/Cluster.pm]
    # my $result = $hostObj->Reboot();
    # what is the class of $hostObj ?
    # class/type ($hostObj) = HypervisorOperations.pm
  # For now, create the inline python object and leave a note stating that it needs to be tested
    once Shashank is back
 # Code has been committed : commit 64465ad35b91a88b2c0866c04b709c2496b33fa4
   # Author: Sabesan Saidapet Pachai <ssaidapetpach@vmware.com>
   # Date:   Fri Feb 13 15:48:55 2015 -0800

      Modified SetVMotion api to use the pylib api enable_vmotion instead of the usual staf sdk call
    
      Issue: #
      Change-Id: I8cdf144828ece68a91553fd09562f98c65f67bec  	      

# S21 : next api => GETVMXFILEPATH (Common/Utilities.pm) 

 # Transformation object
  # staf_sdk_call = "GETVMXFILEPATH"
  # file = "Common/Utilities.pm"
  # pylib_file = "vmware/vsphere/vm/vm10_vm_impl.py"
  # pylib_api = "get_vm_spec_path"
 # 2 files that need to be opened 
  # file to be manipulated = file {perl module file where the replacement is supposed to occur}
 # associated problem => how do I create a vm client object first (GetInlinePyObject does not work here)
 # there must be some way of instantiating a vm client object api instance from the vm name
   which is not explicit here
 # postpone all tasks related to Utilities.pm to the end until this thing is resolved
 # Take notes in automation project plan


# S22 : amend the existing commit (SetVmotion api) 

 # drop local commits in the master branch => "git reset --hard origin/master"
 # git commit --amend -m "DO NOT MERGE : blah blah blah"


# S23 : next api => LISTPORTGROUP

 # keep the ssh connection on the client alive 
  # locate ssh_config file on machine
  # not_present => create one
 # staf_call = LISTPG
 # file = Portgroup/PortGroupConfig.pm
 # pylib_file = pylib/vmware/vsphere/esx/vsswitch/portgroup/api/esx55_crud_impl.py 
 # pylib_api = read() : 
 # last statement in perl => break statement in C which breaks the loop
 # need to include the discussions with Prabuddh., please take a photo on iphone
  # write code for getting inline python objects in switch and portgroup objects 
  # filed bug_1403074 for a file called "VDNetLib/Portgroup/PortGroupConfig.pm"
  # file = VDNetLib/Switch/VSSwitch/PortGroup.pm
  # stash changes in the file
  # reapply the stashed changes to the file
  # before that, check that the old changes are in
  # yes => the new changes that were stashed are gone {as_expected}
  # reapply the stashed changes {git stash apply stash@{0} }
  # delete stashed changes => {git stash drop}
  # data_format = [VSwitch_name,PortGroup_Name,vlan] -> NetworkSchema
  # pylib_api = read(cls, client_object) 
  # how does the pylib_api get invoked using HypervisorOperations as an example ?
   # files = [HyperVisorOperations]
   # api : CreateInlinePythonObject($self->{_pyClass},
                                    $self->{hostIP},
                                    $self->{userid},
                                    $self->{sshPassword});
   # what does $self->{pyclass} contain ?
   # HostOperations.pm -> constructor(new) -> pyclass{vmware.vsphere.esx.esx_facade.ESXFacade}
   # what transformations are needed to accomplish this task ?
    # [VSSwitch.pm]
     # t1 => transform vsswitch_facade.py equivalent to logical_switch_facade.py
      # file = pylib/vmware/nsx/manager/logical_switch/logical_switch_facade.py
      # make sure that things are aligned in terms of signatures here
      # prepare(infrastructure_to_test) : 
       # reuse(reboot.yaml) 
       # esx55 deployment, host_ip = 10.144.138.159, user =root , passwd = ca...
       # test_command = python vsswitch_facade.py -s 10.144.138.159 -u root -p ca\$hc0w
      # testing_method => produced an error (not worth debugging) 
      # alternate_test_method() => find test code that uses "LISTPORTGROUP" api   
     # t2 => introduce pyclass in new of VSSwitch.pm like this : $self->{_pyClass} = "vmware.vsphere.esx.vsswitch.vsswitch_facade.VSSwitchFacade"  
     # t3 => GetInlinePyObject() => return CreateInlinePythonObject(
                                    pyclass = "vmware.vsphere.esx.vsswitch.vsswitch_facade.VSSwitchFacade",
                                    name = $self->{'switch'}, parent = $self->{'hostOpsObj'}->GetInlinePyObject()
   # need to put this on hold and think about a different strategy 	
      
                                                                    

# S24 : gitreview compilation links 

 # https://gitreview.eng.vmware.com:8443/15873
 # https://gitreview.eng.vmware.com:8443/15874

 

# S25 : Understand the pylib api design

 # choose a folder : vdnet/automation/pylib/vmware/vsphere/esx/api/
 # esx_impl -> {adapter, hypervisor, network, power, service, vm}
 # esx_api_client.py, __init__.py
 # why is __init__.py used ?
  # no content in __init__.py
  # in general, why would you need this file ?
  # __init__.py => tells the interpreter that the directory is a pythonic module
 # what is adapter impl ?
  # contains adapter info related to the esx host
  # extends from AdapterInterface
 # class(object): definition -> what is this ?
  # new style classes inherit from object
  # class methods => methods that belong to a class
    and need not be invoked using a class instance, rather the class
    itself
 # trace the function call flow from the entry point to the end for reboot api
  # strategy_1 : dump all function names in the log file
   # deploy 2 esxi hosts using reboot.yaml to prepare for running the test
   # copy the vdnet test log directory
    # /tmp/vdnet/20150224-194847/1_TDS.EsxServer.VMKTCPIP.VMKTCPIP.EEsxReboot/testcase.log
    # write a python script to parse this log with brackets and reuse the script here  
     # scp ssaidapetpach@10.144.138.31:/tmp/vdnet/20150224-194847/1_TDS.EsxServer.VMKTCPIP.VMKTCPIP.EEsxReboot/testcase.log Algorithms/clrs/sample.log
     # grep -> binary file (standard input) matches
     # use grep -a --text instead : 
       example => "grep -a --text \\[@ sample.log"
     # use --debug option while executing the test case
     # learn perl debugger
      # how do you print the contents of a variable, say $mine inside a perl debugger ?
      # "x $mine" prints the value of "mine" variable 
      # neat_technique to step through the code in the debugger mode 
      # note down all data structures along the way when this code is being  debugged   
   
# S26 : Onboarding tasks for Shashank 

 # file_bug(1404961)
 # get_vm_by_name errored: AttributeError("'NoneType' object has no attribute 'GetChildEntity'",) 
 # got a successful test case run of EEsxReboot 
 # task allocated => print all file_names, line numbers for an end-end vdnet test case
 # 
