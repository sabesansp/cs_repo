P : Go through the python apis written by Shashank and replace the staf calls inside vdnet with these apis

[4368 mins]


# S1: Download the api mac timer to record the time taken to complete this activity
                 
                 
# S2: Write down a preliminary plan for completing this activity

 # Pick one api like "powerOff" 
 # Follow the same process as "powerOn" implemented by Prabuddh
 # Initial definition of process : code -> test -> review -> rework * {goes back to code}
                                   ------------------------> check-in 
 # api_1 -> code -> test -> review -> rework
         -> code -> test -> review -> rework
         -> code -> test -> review -> check-in
   [ a sample cycle which has two rework units based on comments ]
                 
                 

# S3 :  To be able to implement the plan what would be required ? {"pre-req"}


 # File a bug for completing the task
  # bug_number = [#1374435]
  # link_bookmark() // bookmarks the link for the bug

 # Set up the vdnet code base on dbc
  # command  = "ssh ssaidapetpach@pa-dbc1109.eng.vmware.com" | password = "*"
  # n[files_modified] = 2


  # "SP" : Issue a command like "dbc-connect" from command line and connect to the place where repo is checked out
   # use alias called "dbc-connect" and place $command as the value in bash_profile

   # "SP" : makeLoginPasswordless()
    # from host, generate key "ssh-keygen -t rsa"
    # public key stored in "/Users/ssaidapetpach/.ssh/id_rsa"
    # copy the key and move it to the target host using a command like
      --- cat ~/.ssh/id_rsa.pub | ssh b@B 'cat >> ~/.ssh/authorized_keys'---
  
  # "SP" : setup the vdnet master controller to be able to execute the code
   # login into the esx host and check the ip of the master controller 
   # forgot the ip of the esxi host and unable to login
   # use the kvm switch to check the console
   # kvm switch not operational
   # File a "HelpNow" ticket for this issue {INC0087727} 	  
    # This is up for review tomorrow morning (12/17/2014}
    # ---problem solved here---  
   # esx_host_ip = 10.33.75.228

 # Go through the link Prabuddh sent :
  # link l = [https://gitreview.eng.vmware.com:8443/#/c/10978/,
              https://reviewboard.eng.vmware.com/r/656157/] 
  # files
    - TDS/EsxServer/Stability/RPMTTds.pm
    - VDNetLib/VM/ESXSTAFVMOperations.pm
    - pylib/vmware/vsphere/vm/api/vm10_power_impl.py
    - pylib/vmware/vsphere/vm/api/vm_api_client.py
  # Shashank's code link l1 = [nsx-qe/vdnet/automation/pylib/vmware/vsphere/] 
  # Sent comments on the review on gitreview


# S4 : Implement the vmops power off function first
 
 # file = "VDNetLib/VM/ESXSTAFVMOperations.pm"
 # precondition =  "Prabuddh checking in the file"
 # plan what sort of implementation will go into the file
 # comment in the bug about the precondition
 # waitForCheckin()

# S5 : Access the vdnet master controller [sub-problem from S3]

 # Deploy a windows 7 enterprise edition vm in fusion
  # Where can I find a windows 7 vm ? 
  # search("source.vmware.com")
  # link = "https://kb.eng.vmware.com/node/1813"
  # follow the steps in the "link" above  
 # Install vsphere client in the vm to access esx box (10.33.75.228)
  # where can I get vsphere client ESXi 5.0.0 ?
  # search("source.vmware.com",
           "vsphere client for ESXi 5.0.0"))
  # link = "vilib.eng.vmware.com/Binaries"
  # bring_in("latest_vsphere_client_build")
 # vdnet_mc_ip = 10.33.74.138
 # find("vdnet_site_page)
  # link = "https://sites.google.com/a/vmware.com/vdnet/" {bookmarked}

# S6 : Evaluate if a new vdnet master controller can be deployed in wdc
 
 # search("vdnet_site")
 # mc_deployment_pod = ~netfvt/wdc-mc
 # ucs_private_cloud = vc_ip = 10.144.136.10 {login (user:root/pwd:ca$...)}
 # NIMBUS_ovf_deploy_command here:
  # NIMBUS_CONFIG_FILE=~netfvt/master-config.json NIMBUS=wdc-mc /mts/git/bin/nimbus-ovfdeploy -d ssaidapetpach-mc-x86-1 <link_to_ovf>
 # Do not use the nimbus-ovf-deploy command, instead deploy ovf in MC-depository directly
  # vmware_client_integration plug-in needs to be installed first on the vsphere web client
  # install("vmware_client_integration_plugin")
  # manual deploy of ovf in "MC-depository" resource pool 
  # wait("until_deployment_completes")

# S7 : On the new vdnet master controller, test deployment of a sample vm with guest os

 # search(src="vdnet_site",
          keyword="vm_deployment")
 # ip_recv = 172.* on vlan 27
 # change vlan to fabric A 1360  and restart the vm
 # vdnet_mc_ip {wdc-lab} = 10.144.137.217
 # program_passwordless_login(vdnet_mc_ip)
 # use("~/yaml/sample.yaml") on dbc
 # NOTE : 29 mins down, yet to find the "context"
 # "SP": deploy vc, esxi, a vm with gos on esxi
  # rpmt yaml => copied over to "~/yaml/rpmt.yaml"
  # add "ssaidapetpach" to sudoers file => 
    "sudo adduser ssaidapetpach sudo"
  # "SP": No deploy_testbed.log gets created
   # String = "Checking or deploying testbed, please wait.. watch deployment logs at 
               /tmp/vdnet/20141222-172625/deploy_testbed.log"
   # There is no file ("deploy_testbed.log") created in the specified folder
   # Where is this log statement printed in code ?
   # VDNetLib::Session::Session:2726
   # "SP" : At what point in the code is "deploy_testbed.log" created ?
    # search("deploy_testbed.log") : 
      grep -i -r -v "deploy_testbed" <path_to_folder>
    # The search results were not useful
    # Start from the entry point "E" : vdnet/automation/main/vdnet
    # calls "e1" : vdnet/automation/main/vdNet.pl
    # calls "e2" : new() {vdnet/automation/VDNetLib/Session/Session.pm}
    # calls "e3" : ConfigureLogging() {vdnet/automation/VDNetLib/Session/Session.pm}
    # ...calls "e4" : setup_logging() {vdnet/automation/scripts/deployTestbed.py}
     # does not create the file "deploy_testbed.log" even though it is defined as a file handler for logging
     # a separate prototype for this works to create the file in the same directory as the code tries to do
   # re-run the test case with a higher log level
   # set up a dbc account in wdc
   # 22 mins for the next line to be printed after "deploy_testbed.log"
  # "SP": VM deployment fails
   # vc.1 ip address: 10.144.137.107,
     esx.1 ip address: 10.144.138.186, 
     esx.2 ip address: 10.144.138.136
     vm.1 => powered on || 
     name => 1-RHEL63_srv_64-local-1056-582dae85-67af-48d1-9d18-0f1e8792cbe0 || 
     path => /vmfs/volumes/datastore1/vdtest-12300/VM-1/RHEL63_srv_64.vmx
     
   # 322 secs [FAIL]
   # useful links
     Session log file: /tmp/vdnet/20141223-184933/vdnet.log
     Racetrack link: http://racetrack.eng.vmware.com/result.php?id=1996575
     Base log dir for this session: /tmp/vdnet/20141223-184933
     Debugging tips	: http://goo.gl/Gllc1k
     Perl exited with active threads:
	1 running and unjoined
	1 finished and unjoined
	0 running and detached    


# S8 : Complete "reboot()" method first in HostOperations.pm since it is taking time to check in

 # update_bug(msg) : bug_1374435
 # infrastructure : 1 esxi host
 # reboot.yaml : one_esxi_host
 
 # SP => Cannot login into mc {10.144.137.217} 
  
  # mc was powered down
  # power up the mc
  # ping the old ip => pingable
  # vdnet_mc_ip changed
  # vdnet_mc_ip = "10.144.138.31"
  # login_problem_solved

 # SP => mount point for w2-dbc201 was not present in mc 

  # root_cause = "ip_changed" => "mount_points_lost"
  # cmd  = "sudo mount w2-dbc201.eng.vmware.com:/dbc/w2-dbc201/ssaidapetpach /dbc/w2-dbc201/ssaidapetpach"
  # logout and test_login()
  # prompt = $vdnet_src_dir

 # SP => Figure out a specific test case for reboot 

 # SP => Code up the condition and understand the flow of the code 

  # File = VDNetLib/Host/HostOperations.pm
  # Set_of_Transformations 'T' = {
   # Add "VDNetLib::InlinePython::VDNetInterface qw(CreateInlinePythonObject
                                                    ConfigureLogger 
                                                    CallMethodWithKWArgs);"
     in the beginning
    # qw => inserts quotes around the words and passes it to use function
      which will use the functions from VDNetInterface
   # In reboot() => add this line $pyObj = $self->GetInlinePyObject()
   # $result = CallMethodWithKWArgs($pyObj, 'reboot', {});
     {this method defined in pylib/vmware/vsphere/esx/api/esx55_power_impl.py}
   # comment the old code and put in the new code
   
  # Test_Case : EsxServer.VMKTCPIP.VMKTCPIP.EEsxReboot
   # comment out rest of the parts
   # problem while executing the testcase 
   # needs to be dealt with, as a separate sub-problem 



# S9 : Come up with a strategy to comment lines 40-93

 # comment : apply('#')
 # try command = ":40,93s/^/#"
 # this command works
 # for uncommenting command = ":40,93s/^#/"
 

# S10 : Solve sub-problem {node /testbed/host/1 obj does not exist}

 # base log dir : /tmp/vdnet/20150106-200432
 # Use this as the basis for solving this problem 
 # changeDir(1_TDS...)
 # error_msg_1 = "Node /testbed/host/1 does not exist"
 # code_unit = "VDNetLib::Common:Zookeeper:412"  
 # esx.1.ip address = 10.144.139.87 {extend_lease() as appropriate}
 # try to save the testbed first 
 # base log dir = /tmp/vdnet/20150107-154100
 
 # search(zookeeper_base_log_dir)
  # zookeeper_base_log_dir = "/tmp/vdnetsnap/rpmt/zookeeper-19816"
  # changeDir(zookeeper_base_log_dir)
  # found(bunch_of_scripts)


 # reboot the mc and retry()
 # saw the same error
 # Reason : The testbedspec in the tds was empty and nothing got written to zookeeper node
 # populated the testbedspec in tds and the error was gone


# S11 : Received an exception "InvalidState" while executing the reboot api

 # msg = "The operation is not allowed in the current state"
 # The "Force" parameter needs to be set to true
 # Pass this parameter in the KW arguments list 
 # When 'True' is passed, there is a runtime error
 # passHash('force' => 'True') : {ERROR} => expecting bool but got a str
 # passHash('force' => True) : {SYNTAX_ERROR}
 # passhash('force' => 1) : {NO_ERROR}


# S12 : Implement the check-in 

 # deploy 2 esxi => 10.144.139.91, 10.144.138.132
 # test passes :  http://racetrack.eng.vmware.com/result.php?id=2023036
 # prepare(code_checkin)
  # post review => https://sites.google.com/a/vmware.com/vdnet/Miscellaneous/10-0-git-vs-perforce/use-case-1
  # delete whitespaces at end of line & remove tabs => ":%s/\s\+$//"
  # post-review <commit-id>
  # git commit --amend <file>
  # post-review <commit-id> -r <review_num> {re-post into the same review_num}
  # git push review HEAD:refs/for/master {push to gerritt -> submit} 
  # git push ssh://rams@gitreview.eng.vmware.com:29418/nsx-qe HEAD:refs/for/master (add it to bash profile or something) 

# S13 : Pick second api to be completed

 # LISTVSWITCH could be a candidate
 # source_file = "...Switch/VSSwitch/VSSwitch.pm"
 # line_number = 126 {first_usage_of_LISTVSWITCH}
 # pylib_file = "pylib/vmware/vsphere/esx/vsswitch/api/esx55_crud_impl.py"
 # usedPorts in tuple at source_file does not correspond to numPortsAvailablein SwitchSchema
 # !correspondence(usedPorts{source_file},
                   numPortsAvailable{pylib_file}) // code to convert the previous line
  # N{tests(GetvSwitchProp)} => 0   
 # -diversion-coursera      
 # -diversion-gambit-scheme


# S14 : Unit test review { https://reviewboard.eng.vmware.com/r/731281/ }

 # author : prabuddh
 # review published : {optimization, blank_spaces}

# S15 : shortlist a set of apis to be transformed into the pylib equivalent

 # -diversion-send-solution-on-pyvim-sslthumbprintdata-add-host-to-cluster
 # api_list_1 = [LISTVMKNIC, UPDATEPCIPASSTHRUCONFIG, LISTNICS, LISTDVPG, DISCONNECT]


# S16 : Work on "api_list_1"

 # api_list_1[0] = LISTVMKNIC
  # api.location = Host/HostOperations.pm : 4724
  # api.name = "ListVmknics"
  # api.callers = ["/Workloads/HostWorkload.pm",
                   "/Workloads/AbstractSwitchWorkload.pm"]
  # function : transform()
  # transform() { copy_transform(reboot);}
  # lines = { my $pyObj = $self -> GetInlinePyObject(); ||
              my $result = CallMethodWithKWArgs($pyObj,'listvmknics');
  # pylib_api_location = "...pylib/vmware/vsphere/esx/api/esx55_adapter_impl.py"
  # pylib_api_return = list_vnic() // returns nics to the caller 
  # If there are no vmknics, "nics" datastructure would be empty from pylib
  # There will be no case where this will return null
  # Checks in the caller have to be modified accordingly
  # "list_vnic" method returns the list of virtual nics {python list}
  # "ListVmknics" routine in HostOperations.pm expects a hash stored in $result -> {result} 
  # what does $result -> {result} contain ?
   # examine api.callers
   # context(usage) :
    # my $result = $hostObj -> ListVmknics()
    # check() : ref($result) eq "ARRAY"
    # foreach item : @$result
    # if($item -> {'Interface'}  =~ m/$interface/i) {vssPortgroup = $item -> {'PortGroup'} [AbstractSwitchWorkload.pm]
    # if($item -> {'PortGroup'} eq $hostOpsHash -> {testpg}) { $device = $item -> {'Interface'}; [HostWorkload.pm] 
  # find one test that uses ListVmknics
   # test_case : "EsxServer.VMKTCPIP.VMKTCPIP.RFRoute" deletes vmknics in its workflow sequence
   # needs only one esxi host {which is a good candidate for testing}
   # reuse reboot.yaml for testing purposes
   # spawn the testbed :  ./vdnet/automation/main/vdnet -c ~/yaml/reboot.yaml -t EsxServer.VMKTCPIP.VMKTCPIP.RFRoute --testbed save
  # deployed_esx_ip : 10.144.138.63
  # flip number of iterations to 1 instead of 20 in the TDS
  # passed_log : http://racetrack.eng.vmware.com/result.php?id=2056531

  # p1 : Unable to get a print statement to the log from ListVmknics (Is this method even being called ? )
   # Need to start from this section tomorrow (verify the code flow path)

  # p2 : changes had to be discarded because of a problem in git workflow
   # Need to solve this problem of merging code before proceeding to avoid such pitfalls



# S17 : Choose one api to be worked upon and submit it in the git repo {api chosen = LISTNICS}

 # Choose a test that exercises the GetPCIId code path 
 # file that contains the pylib api = ...pylib/vmware/vsphere/esx/api/esx55_adapter_impl.py
 # pylib api = "list_pnics"
 # testcase to be run that involves "EnableFPT"
 # key_handle = "...VDNetLib/Workloads/HostWorkload.pm" : method = "InitializeHostPhysicalComponents"
 # what is the key used to init the vmnics ? => passthrough
 # do not test this now : make changes for each api and make a local commit in a local git branch
 # need to address S16.p2 ASAP with an urgency



# S16.p2 : Resolve the git workflow for committing the changes to the pylib apis 

 # Make a change for api_1 {LISTVMKNICS} for example and commit in a local branch
 # Do not worry about testing this method yet 
 # implement the change for LISTVMKNIC using the pylib api
 # commit the change to the api in the local branch
 # "delta-f" is stored in the local repository
 # run a small experiment
  # examine the file HostOperations.pm on master branch and check if the change was available
  # the change is not available as expected which confirms the theory that the pylib-api-calls branch has an updated version of the file
  # changes made to a certain file are only local to a given repo
 # good read : http://www.git-scm.com/book/en/v2/Git-Branching-Basic-Branching-and-Merging
 # chapter 5 of git workflow also might be of importance to the reader


# S18 : Take a count of the apis that have been completed to establish context
 
 # 1 api => LISTVMKNICS 
 # replay the commit on top of the existing commit => rebase to master from pylib-api-calls


# S19 : Implement a commit on the next set of apis [ UPDATEPCIPASSTHRUCONFIG, LISTNICS, LISTDVPG, DISCONNECT ] 

 # Make notes on why I am not taking up these apis now {on the google_docs}


# S20 : Next api to be implemented => selectvnic()/deselectvnic() | pylib_api = "enable_vmotion"

 # file_to_be_changed {fn} = "VDNetLib/NetAdapter/Vmknic/Vmknic.pm" {fn} 
 # method_to_be_changed {mn} = "SetVMotion"
 # lookup(fn) && change(mn) 
 # Q1 => what object needs to be passed as "client_object" into the enable_vmotion api ? 
 # Q1 needs to be answered first thing in the morning tomorrow
 # postpone(Q1)
 # why is the portgroup name passed as a parameter to "mn" ?
  # Enable/disable the vmknic connected to the portgroup that has the portgroup name
  # enable_vmotion(vmknic | connected(vmknic, pgname))
 # Design_question : Why is the portgroup name passed as a parameter to enable/disable vmknic ?
  # probably due to the constraint imposed by the staf sdk call
  # constraint{staf_sdk_call} - Probability
 # What are the steps to be taken in order to transform this into a pyvim api call ?
  # p1 : Get the vmknic object and call enable_vmotion on that object
  # api : enable_vmotion(cls, client_object, enable=None)
  # cls -> class, client_object -> object to be invoked, enable -> parameter
  # steps for accomplishing p1 is not clear yet
 # How can p1 be solved ?
  # client_object -> instance_of(vmknicAPIClient)
  # How can I create vmknicAPIClient instance ?
   # Before solving this, how did the reboot api work ? {workflow}
    # my $pyObj = $self->GetInlinePyObject();
    # what does $self contain ?
    # search for callers of reboot() api 
    # caller = api : "RebootHostsInClusterSequentially()": 
               file :  [..VDNetLib/VC/Cluster.pm]
    # my $result = $hostObj->Reboot();
    # what is the class of $hostObj ?
    # class/type ($hostObj) = HypervisorOperations.pm
  # For now, create the inline python object and leave a note stating that it needs to be tested
    once Shashank is back
 # Code has been committed : commit 64465ad35b91a88b2c0866c04b709c2496b33fa4
   # Author: Sabesan Saidapet Pachai <ssaidapetpach@vmware.com>
   # Date:   Fri Feb 13 15:48:55 2015 -0800

      Modified SetVMotion api to use the pylib api enable_vmotion instead of the usual staf sdk call
    
      Issue: #
      Change-Id: I8cdf144828ece68a91553fd09562f98c65f67bec  	      

# S21 : next api => GETVMXFILEPATH (Common/Utilities.pm) 

 # Transformation object
  # staf_sdk_call = "GETVMXFILEPATH"
  # file = "Common/Utilities.pm"
  # pylib_file = "vmware/vsphere/vm/vm10_vm_impl.py"
  # pylib_api = "get_vm_spec_path"
 # 2 files that need to be opened 
  # file to be manipulated = file {perl module file where the replacement is supposed to occur}
 # associated problem => how do I create a vm client object first (GetInlinePyObject does not work here)
 # there must be some way of instantiating a vm client object api instance from the vm name
   which is not explicit here
 # postpone all tasks related to Utilities.pm to the end until this thing is resolved
 # Take notes in automation project plan


# S22 : amend the existing commit (SetVmotion api) 

 # drop local commits in the master branch => "git reset --hard origin/master"
 # git commit --amend -m "DO NOT MERGE : blah blah blah"


# S23 : next api => LISTPORTGROUP

 # keep the ssh connection on the client alive 
  # locate ssh_config file on machine
  # not_present => create one
 # staf_call = LISTPG
 # file = Portgroup/PortGroupConfig.pm
 # pylib_file = pylib/vmware/vsphere/esx/vsswitch/portgroup/api/esx55_crud_impl.py 
 # pylib_api = read() : 
 # last statement in perl => break statement in C which breaks the loop
 # need to include the discussions with Prabuddh., please take a photo on iphone
  # write code for getting inline python objects in switch and portgroup objects 
  # filed bug_1403074 for a file called "VDNetLib/Portgroup/PortGroupConfig.pm"
  # file = VDNetLib/Switch/VSSwitch/PortGroup.pm
  # stash changes in the file
  # reapply the stashed changes to the file
  # before that, check that the old changes are in
  # yes => the new changes that were stashed are gone {as_expected}
  # reapply the stashed changes {git stash apply stash@{0} }
  # delete stashed changes => {git stash drop}
  # data_format = [VSwitch_name,PortGroup_Name,vlan] -> NetworkSchema
  # pylib_api = read(cls, client_object) 
  # how does the pylib_api get invoked using HypervisorOperations as an example ?
   # files = [HyperVisorOperations]
   # api : CreateInlinePythonObject($self->{_pyClass},
                                    $self->{hostIP},
                                    $self->{userid},
                                    $self->{sshPassword});
   # what does $self->{pyclass} contain ?
   # HostOperations.pm -> constructor(new) -> pyclass{vmware.vsphere.esx.esx_facade.ESXFacade}
   # what transformations are needed to accomplish this task ?
    # [VSSwitch.pm]
     # t1 => transform vsswitch_facade.py equivalent to logical_switch_facade.py
      # file = pylib/vmware/nsx/manager/logical_switch/logical_switch_facade.py
      # make sure that things are aligned in terms of signatures here
      # prepare(infrastructure_to_test) : 
       # reuse(reboot.yaml) 
       # esx55 deployment, host_ip = 10.144.138.159, user =root , passwd = ca...
       # test_command = python vsswitch_facade.py -s 10.144.138.159 -u root -p ca\$hc0w
      # testing_method => produced an error (not worth debugging) 
      # alternate_test_method() => find test code that uses "LISTPORTGROUP" api   
     # t2 => introduce pyclass in new of VSSwitch.pm like this : $self->{_pyClass} = "vmware.vsphere.esx.vsswitch.vsswitch_facade.VSSwitchFacade"  
     # t3 => GetInlinePyObject() => return CreateInlinePythonObject(
                                    pyclass = "vmware.vsphere.esx.vsswitch.vsswitch_facade.VSSwitchFacade",
                                    name = $self->{'switch'}, parent = $self->{'hostOpsObj'}->GetInlinePyObject()
   # need to put this on hold and think about a different strategy 	
      
                                                                    

# S24 : gitreview compilation links 

 # https://gitreview.eng.vmware.com:8443/15873
 # https://gitreview.eng.vmware.com:8443/15874

 

# S25 : Understand the pylib api design

 # choose a folder : vdnet/automation/pylib/vmware/vsphere/esx/api/
 # esx_impl -> {adapter, hypervisor, network, power, service, vm}
 # esx_api_client.py, __init__.py
 # why is __init__.py used ?
  # no content in __init__.py
  # in general, why would you need this file ?
  # __init__.py => tells the interpreter that the directory is a pythonic module
 # what is adapter impl ?
  # contains adapter info related to the esx host
  # extends from AdapterInterface
 # class(object): definition -> what is this ?
  # new style classes inherit from object
  # class methods => methods that belong to a class
    and need not be invoked using a class instance, rather the class
    itself
 # trace the function call flow from the entry point to the end for reboot api
  # strategy_1 : dump all function names in the log file
   # deploy 2 esxi hosts using reboot.yaml to prepare for running the test
   # copy the vdnet test log directory
    # /tmp/vdnet/20150224-194847/1_TDS.EsxServer.VMKTCPIP.VMKTCPIP.EEsxReboot/testcase.log
    # write a python script to parse this log with brackets and reuse the script here  
     # scp ssaidapetpach@10.144.138.31:/tmp/vdnet/20150224-194847/1_TDS.EsxServer.VMKTCPIP.VMKTCPIP.EEsxReboot/testcase.log Algorithms/clrs/sample.log
     # grep -> binary file (standard input) matches
     # use grep -a --text instead : 
       example => "grep -a --text \\[@ sample.log"
     # use --debug option while executing the test case
     # learn perl debugger
      # how do you print the contents of a variable, say $mine inside a perl debugger ?
      # "x $mine" prints the value of "mine" variable 
      # neat_technique to step through the code in the debugger mode 
      # note down all data structures along the way when this code is being debugged
      # write a simple test case and have a sample execution through the perl debugger
       # addvmknic, deletevmknic sequence in the set of workloads
       # copy  a test case : RFRouteNew 
       # VDNetLib::TestSession::TestSession.pm => RunTest() 
       # SetWorkloadManagerObj() => new VDNetLib::Workloads::WorkloadsManager() 
       # RunWorkload() {in WorkloadsManager class} 
   
# S26 : Onboarding tasks for Shashank 

 # file_bug(1404961)
 # get_vm_by_name errored: AttributeError("'NoneType' object has no attribute 'GetChildEntity'",) 
 # got a successful test case run of EEsxReboot 
 # task allocated => print all file_names, line numbers for an end-end vdnet test case
 # EEsx.VMKTCPIP.VMKTCPIP.RFRoute => test_case in TDS to be run for a single iteration (not iterations = 20) 
 # vdnet/automation/TDS/EsxServer/VDS/VDS/vNicMigration
 # [ERROR] - Unable to create vswitch migrate-to-net
  # unable_to_create_vswitch()
  # vswitch already present
  # code failed with a different reason first time
  # reason = "could not find portgroup migrate-pg"
  # vss portgroup was referenced by name rather than host.[1].portgroup.[1]
  # find all references of migrate-pg and replace it with "host.[1].portgroup.[1]"
  # cleanup code failed to cleanup because the host was already removed from the vc
  # re-initializing the setup for deployment and testing


# S27 : api_chosen = CreateDC (VCOperation.pm)

 # vc_build = 1312297
 # change is pretty simple, summarized below :
  # get the inline python object
  # got complicated at a certain point
  # revert to a different plan
  # need to stay with this => not_a_good_day()
 # problem(_simple) => problem(_complicated) when mind is not aligned with the task
 # createdatacenter api is invoked on a folder
 # this info is not captured in the current code explicitly 
 # when datacenter is being created, where is it being created ?
  # folder must be specified explicitly but I do not find folder name anywhere in CreateDC
  # run a sample test case in order to test this code path
  # deploy a vc with this build 
  # print the hash => Dumper($result);
  # what is a better option to print the data structure ?
   # option_1 => invoke the method createdc alone
   # option_2 => invoke a test case that calls into one of the callers of the method
   # option_2 seems more easy at this point
   # callers = [CreateDCWithHosts, AddDCWithHosts] 
   # search_caller_in_callers for respective TDSes
   # CreateDC -> AddDCWithhosts -> VCWorkload.pm -> keys_db_entry {'datacenter'}
   # problem => find a test_case to run 
    # test_case should involve the method "AddDCWithHosts" subroutine
    # key_db_entry{'datacenter'} in VCWorkload.yaml calls this subroutine
    # reduce(problem) => any testcase that invokes 'datacenter' key in TDS
    # test_case = Internal.VDNet.Sample.DatacenterPreCheckIn
   # write the yaml file => ~/yaml/sample_vc.yaml
   # edit SampleTds.pm but revert the change made later on 
   # deploy testbed in sample_vc.yaml => threw an error that the yaml could not be parsed which was weird
   # first deploy the vc if possible and remove the host from the yaml file
   # failed as expected but vc.1 ip address =  10.144.139.226
   # deploy esx from reboot.yaml, esx_ip_address = 10.144.139.180
 # make sure that there is a space before and after ":"
 # datacenter-name = "/1-folder-875/1-datacenter-875" 
 # datacenter '1-datacenter-875' created under folder '1-folder-875' under the root folder
 # problem => write pseudo code for computation for creating data center
  # dc_name = "/1-folder-875/1-datacenter-875"
  # calculate the number of slashes = n
  # if n = 1, => create dc-name after / under root folder
  # if n>1 => 
   # get dc-name after the last slash {regex needs to be examined}
   # create a folder object for the name after the root folder
   # create a datacenter inside the folder object
 # sample perl scripts prototypes
  # given an input string like "/f1/dc", print the string after the last slash
   # hardcode the input inside vdnet/sample_scripts.pl
   # compute the last slash in the string and get the string after that {regex}
   # split("/","/f1/dc1") = @split_string || last_string = @split_string[$#split_string]
 # Folder.pm is not present inside the vdnet framework but only exists under InlineJava folder
 # For now, the solution would be to create the inline python object for the folder inside the "CreateDC" api
 # folder_pyclass = "vmware.vsphere.vc.folder.folder_facade.FolderFacade"
 # design_deviation = Shouldn't there be a common Folder perl module like Datacenter to be able to invoke apis ?
 # leave a note that Folder.pm is not available yet and create the inline python object as is 
 # postpone the implementation of this api since "Folder" perl module is not present and a hack needs to be deployed



# S28 : Implement a different api like LISTPORTGROUP
 # pylib_file = esx/vsswitch/portgroup/api/esx55_crud_impl.py || api = read()
 # context_switches are the most expensive {whether it be the human_brain or the computer}
 # vswitch_api_file = VDNetLib/Switch/VSSwitch/PortGroup.pm
 # function = GetPGProperties
 # hierarchy => portgroup_facade -> vss_facade -> host_facade
 # PortgroupFacade(name,vss) || VSSwitchFacade(name,host) 
 # GetInlinePyObject_Not_Defined() => in both vss and portgroup perl modules
 # transformations :
  # t1 => GetInlinePyObject implementation update
   # use the method in Root.pm, have both Portgroup and VSSwitch inherit from Root.pm
   # as an example, check logical_switch in nsx manager
    # two methods => Getid, GetInlinePyObject ($self->{id} : don't know where this property is populated) 
    



# S29 : timeout for mc {mc_not_reachable}
 # ip_addr = 10.144.138.31
 # bookmarked vc ip {10.144.136.10}
 # no mc found for this ip addr, probably got deleted
 # deploy ovf template on mc-depository and choose vlan 1360
 # deployment_in_progress
 # check_deployment_status()
 # vm was not present : need to redeploy the master controller
 # process_started()
 # check_vm_ip() : ip_addr = 10.144.139.229
 # vm ready & operational 


# S30 : Common review tasks
 # https://gitreview.eng.vmware.com:8443/#/c/17218/ 
  # vnic.pm => Fix GetIpv6Global to not return /mask
  # files_list = <path>/vnic.pm
 # https://gitreview.eng.vmware.com:8443/#/c/17161/
  # some nits => {spell_check, 80_char_limit}
  # apis related to HostOperations.pm, hypervisor.py, 
    adapter_interface.py, network_interface.py, esx55_adapter_impl.py,
    esx55_hypervisor_impl.py, esx55_network_impl.py


# S31 : read perl interpreter assembly code 
 # otool -tV /usr/bin/perl {prints the entire assembly code}
 # parse && classify the assembly code
  
# S32 : setup a meeting for drs related tests with opaque switch

 # go through the opaque switch details
 # done (March 17, 2015 => 2:30PM - 3:00PM) 

# S33 : bug triage

 # bug_1413010 => VDNetLib::InlinePython::VDNetInterface:340 -> python method returned an exception "No route to host"
  # VDNetLib::InlinePython::VDNetInterface: 312 => "no route to host"
  # VDNetLib::Root:Root:78
  # target_end_point not reachable {buildweb, host on which modules were being deployed}
  # INCOMPLETE => {analysis not complete with concrete leaves}
 # bug_1413974 => [@VDNetLib::Workloads::TrafficWorkload::TrafficTool:1667] [4530] Command:netstat -nlp | grep 49171 failed on 10.153.214.118 
  # testcase => NSXTransformers.L2.L2Sample.L2ESXBasic
  # which workload failed => CombinedTraffic
  # closest error in log => Traffic client failed for 0000-vm.[1].vnic.[1]<---0001-vm.[2].vnic.[1]inbound
  # class_of_problems = "netperf"
  # launch netserver on 10.153.214.118 : /automation/bin/x86_32/linux/netserver -p 49171 -6 -L 2001:bd6::c:2957:214:118) on 10.153.214.118 with PID: <none>
  # INCOMPLETE => {analysis not complete with concrete leaves}  


# S34 : Product_basics

 # esx_host
  # no two portgroups can have the same name even if they are on different virtual switches
  #    	


# S35 : Patterns 

 # Call GetPGProperties with a portgroup object
  # Use DeleteVmknic method => get host object, get vswitch obj, get portgroup obj, call GetPGProperties on portgroup obj
 # while reading a piece of text convert it into a problem thread(goal is to get from point A to point B)   	

       

# S36 : Problem - Logging + Result_Reporting

 # requirements(note down the thought process)
  # req001 - store logs and report to a server which stores it in the db
  # req002 - ability to manipulate reporting capabilities
  # req003 - ability to pull down reports on any device (mobile/desktop etc.)
  # req004 - ability to serve multiple requests
 # quick prototype to clarify the requirements
  # python script that writes a string to a log file
   # file = lrr_prototype.py 
   # path =  ~/cs_repo/ vdnet/lrr_prototype.py
   # print a random string "This is a test string"
   # use a logging library api to push this to a log file
     [reqd_outcome = string in file] 
      # import logging module
      # 


# S37 : resolve bug 1415054

 # pt -> lot of DEBUG logging is no-op (remove all unwanted logging)
  # sample = [@VDNetLib::Common::LogCollector:345] 
  # Log collection method is GetNSXControllerLog,logobj is nsxcontroller,objTuple is nsxmanager.[-1] 
  # needinfo() : need a direction for bug resolution
  # for different products, we need to collect logs which do not work => resolve
    on a case-by-case basis and not remove unwanted logging statements
  # direction : remove all invalid combinations
  # log_collection_method = "GetKVMLog" | log_obj = "kvm" |  objTuple = "nsxmanager.[-1]"
  # LOGFUNCTIONMAP => contains the object and method to be called for log_collection
  # kvmLog => {object = 'kvm',method = 'GetKVMLog'} 
  # collect_logs => "pylib/vmware/kvm/kvm.py" method only has a "pass" in it
  # U(CollectLog) => VDNetLib/Common/LogCollector.pm
   # params => $workloadType, $objTuple
   # workloadsubmap => hash ('kvm' => \@kvm) 
   # $workloadkey = 'kvm' || $workloadType = 'kvm'
   # foreach object_tuple in the array of tuples
    # foreach log_type in @$refLogTypeArr
   # @$refLogTypeArr = array(kvmLog) 
   # intuition => @$refLogTypeArray needs to be generated for each object tuple
   # for object_tuple = nsxcontroller.[-1] => $refLogTypeArray = array(nsxcontrollerlog)
   # 'CollectLog' probably needs a complete re-write
   # there must be a map from object tuple to the $refLogTypeArray and then invoke the same
   # $refLogTypeArr = ARRAY_REF
   # insert the trace statement inside each if statement
   # add to technical debt list
   # testcase => NSXTransformers.L3.BasicRouting.FunctionalKVM.BasicIPAddressAssignment
   # yaml_file =>  3kvm_1edge.yaml
   # received an error, need to get the actual command line to run the test case
   # git blame => only reports the most recent errors
  # was able to get it verified and submit but the fix is not getting merged
  # need to see why this issue occurs  


# S38 : research related {shared doc with Jia}

 # list down all the areas that you are interested in
    
     



               	      	   
# S39 : Technical debt 

 # 'CollectLog' subroutine in LogCollector.pm needs to be redesigned 
 



# S40 : resolve bug 1403524

 # problem => --skiptest options is missing from vdnet -help
 # simple to test this out as the output can be copied from console
 # look for skiptest option inside the code
 # files = [main/vdNet.pl,VDNetLib/Session/Session.pm]
 # file_to_be_modified = VDNetLib/Common/VDNetUsage.pm
 # insert the skiptests option
 # send the file out for review
 # patch submitted  	


# S41 : resolve bug 1411545

 # problem => a core dump was detected and the logs were copied onto a specific location
 # The location to which the logs were copied were not mentioned explicitly
 # This resulted in data being hidden from the user and affects ease of debugging
 # DATA_HIDDEN || AFFECTS_EASE_OF_DEBUGGING
 # file = [VDNetLib::Host::HostOperations:16841]
 # CopyCoreDumpFile("/scratch/core", CORE_DUMP . "/" . $host);
 # CORE_DUMP = "coredump"
 # CORE_DUMP_DIR = "/var/core"
 # signature => CopyCoreDumpFile(source_directory, destination_directory)
 # patch submitted to repo 


# S42 : resolve bug 1233000

 # Problem => vdnet help => list all missing options, default values for optional parameters 
   to be more verbose and usable to the user
 # file to be modified = VDNetLib/Common/VDNetUsage.pm
 # list all missing options here :
  # vc, sut, helper,hosts,vms,pswitch,skipsetup,hosted,src,logLevel,consoleLog,vmrepos,
    shared,options,testbed,testconfig,nocleanup,listkeys,configjson, userspec,nsxsdkbuild
  # for each of the missing options 
   # find what the option signifies from the code
   # formulate the right words for the help description
  # vc => most-likely endpoint ip of the virtual center server [optional]
  # sut => ref(testbedv1.pm) => endpoint ip of the system under test [optional]
  # helper => ref(testbedv1.pm) => endpoint ip of helper machine [optional]
  # hosts => (hostlist in Session.pm) => ip addresses /hostnames of hosts [optional]
  # vms => format = "SUT= helper = "
  # pswitch => ip address of the physical switch [optional]
  # skipsetup => do not perform the setup when flag is present [optional]
  # hosted => boolean flag indicating whether this is a hosted setup or not [optional]
  # src => vdnet source path format "<server>:<share>" [optional, default = ]
  # logLevel => 
  # consoleLog 
  # vmrepos
  # shared 
  # options 
  # testbed 
  # testconfig
  # nocleanup 
  # listkeys 
  # configjson 
  # userspec 
  # nsxsdkbuild 
  # reassign to Prabuddh since it has options spanning v1, which ones are irrelevant etc. 
  # -INCOMPLETE_BUT_REASSIGNED-


# S43 : resolve bug 1421918

 # Problem => uninitialized variable in Iterator.pm
 # check for if defined of the $hashWithMagicKeys->{$keys} 
 # in the else part, print that the value of $keys is not present in the hash
 # sent out for review : https://gitreview.eng.vmware.com:8443/#/c/19269/
 # closed the bug
    

# S45 : resolve bug 1345144

 # print smb share info msg when the operation fails
 # file => VDNetLib/VM/VMOperations.pm
 # values to consider => vdNetSrc, vdNetShare
 # default_vdnet_src_server = (vdNetSrc) = scm-trees.eng.vmware.com
 # (vdNetShare) = default_vdnet_src_dir = /trees/vdnet/main/automation
 # logs concerning smb must list both vdNetSrc and vdNetShare
 # or make it something like on "$vdNetSrc:/$vdNetShare" 
 # resolved and closed the bug


# S46 : resolve bug 1425944

 # needinfo on Vikram to know what logs to look into
 # error log line : [@VDNetLib::InlinePython::VDNetInterface:208] [17129] Failed to load module vmware.nsx_api: Error -- 
   py_eval raised an exception at /bldmnt/trees/vdnet/main/vdnet/automation/main/..//VDNetLib/InlinePython/VDNetInterface.pm line 200.
 # move the line in the subroutine into a place where "ne SKIP" is present 
 # link => https://gitreview.eng.vmware.com:8443/19866 

# S47 : resolve bug 1252961

 # tasks to be done as part of this bug :
  # Print the actual command line used
  # Print steps to run repro script
 # put a needinfo on Giri to know the examples for the cases
 # transformations :
  # item #2 :
   # we print only the absolute path to vdnet in the log but not all command line parameters
   # sample statement : Executing vdNet from /bldmnt.../main
   # file -> VDNetLib:Session:Session:109 
   # build a prototype that takes one option and passed as a parameter
   # required statement would be something along the lines of "Executing vdNet <options> from <path"
   # how do you print the options ? @ARGV, etc...
   # review sent : https://gitreview.eng.vmware.com:8443/#/c/20556/
   # fix was submitted
  # item #4 : 
   # needinfo on Giri (need to know what to print) 
   # 

# S48 : resolve bug 1427628

 # Added a defined check for $result
 # fix is out for review : https://gitreview.eng.vmware.com:8443/#/c/20026/1/vdnet/automation/VDNetLib/Host/HostOperations.pm
 # submitted and closed the bug


# S49 : install pre-commit hook

 # instructions :

  # 1. Copy vdnet-dev in all your review requests
 
  # 2. Please ensure pre-commit hook is installed and your review requests contain full commit template
       https://sites.google.com/a/vmware.com/vdnet/developer-guide/coding-style-and-recommendations#TOC-Style-Checking-Helper
 
  # The commit message should contain the following fields
    Issue: -
    Must Review: -
    Review Due Date: -
    Test-Time Impact: -
    Test Run:
    Is Backport Required: -
    Backport of Commit: -
    Follow-Up Work: -
    Pre-Commit Check Ran on the Committed Code: -
 
  # At the minimum, explain what is the change, why is it done,
    any impact.
 
  # Test Run should have racetrack link and/or detailed description of tests run.
 
  # "Pass" is not useful data! It is obvious it should have passed.

 # successfully installed everything to get this thing working (pep8, pyflakes) 



# S50 : resolve bug # 1334835

 # https://gitreview.eng.vmware.com:8443/20662
 # in review at this point
 # fix was submitted : defined check for "id"  


# S51 : resolve bug # 1427511

 # get_latest_vmware_build fails due to IndexError 
   {list index out of range if no build matches with tuple}
 # file = pylib/common/build_utilities.py
 # IndexError:List out of range
 # prototype_construction
  # create a list 'l' with no entities
  # check if l is not empty => if l : 
 # simple fix, but the question is what is the expected workflow
   when data_list is empty (or there is no element in it) 
  # what is the caller of this method ?
  # irrelevant question : not needed at this time
 # resent the fix for review
 # waiting for code review +2
 # fix submitted
  

# S52 : resolve bug # 1426714

 # indentation errors in the yaml file specifying the testbed get caught late in the process
 # construct a prototype for loading the yaml file
  # core logic of loading yaml file is in vdnet_spec.py
  # location of vdnet_spec => "vdnet/automation/scripts/yaml_utils/vdnet_spec.py"
  # <to_be_continued> 

# S53 : resolve bug # 1404333

# S54 : resolve bug # 1367272   	 
